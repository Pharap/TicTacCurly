// fixed the bug granting the computer player an extra turn
// added press b in gameplay to reset game (if playing againced computer 
// that was for testing purposes but i liked it so i kept it
// cleaned up a few things here or there

#include "Arduboy2.h"

enum class GameState : uint8_t
{
  TitleScreen,
  PlayerSelect,
  Gameplay,
};

enum class Cell : uint8_t
{
  None,
  X,
  O
};

Cell oppositeCell(const Cell & cell)
{
  switch(cell)
  {
    case Cell::X: return Cell::O;
    case Cell::O: return Cell::X;
    default: return Cell::None;
  }
}

struct GridPoint
{
  uint8_t x;
  uint8_t y;

  GridPoint() : x(), y() {};
  GridPoint(const uint8_t & x, const uint8_t & y) : x(x), y(y) {};
};
  
Arduboy2 ab;
GameState gamestate = GameState::TitleScreen;
uint8_t players = 1;
uint16_t xwins = 0;
uint16_t owins = 0;
uint16_t ties = 0;
uint8_t xloc = 0;
uint8_t yloc = 0;
Cell turn = Cell::X;

Cell grid[3][3];

const GridPoint gridPositions[3][3]
{
   { GridPoint(7, 7), GridPoint(7, 28), GridPoint(7, 49) },
   { GridPoint(28, 7), GridPoint(28, 28), GridPoint(28, 49) },
   { GridPoint(49, 7), GridPoint(49, 28), GridPoint(49, 49) },
};

const unsigned char player[] PROGMEM  = {
0x3, 0x1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1, 0x3, 0x3, 0x2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2, 0x3, 
};
const unsigned char titles[] PROGMEM  = {
0x00, 0x00, 0x3c, 0xc4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x98, 0x88, 0xe8, 0x18, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x4, 0x84, 0x84, 0x8, 0x8, 0x8, 0x10, 0x90, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0x8, 0x8, 0x8, 0x8, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0xe0, 0x00, 0x00, 0x80, 0x70, 0x10, 0x10, 0x90, 0x10, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x20, 0x90, 0x88, 0x88, 0x90, 0x90, 0x10, 0xa0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3, 0x1, 0x1, 0x2, 0x2, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x4, 0x4, 0x2, 0x2, 0x2, 0x2, 0x3, 0x00, 0x00, 0x00, 0x7e, 0x82, 0x2, 0x2, 0xe, 0xf0, 0x00, 0x00, 0xf8, 0x7, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x81, 0x81, 0x42, 0x42, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6, 0x1c, 0x62, 0x42, 0x22, 0x22, 0x21, 0x17, 0x18, 0x00, 0x1, 0x1, 0x2, 0x2, 0xfc, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0x4, 0x4, 0x4, 0x8, 0x8, 0x1e, 0x1, 0x00, 0xf0, 0xf, 0x00, 0xc0, 0x47, 0x65, 0x86, 0x00, 0x3, 0x3c, 0xc0, 0x00, 0x00, 0xf8, 0x7, 0x00, 0xc, 0x13, 0x20, 0x40, 0x20, 0x20, 0x20, 0x21, 0xa1, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x10, 0x10, 0x10, 0x1f, 0x00, 0x00, 0x1, 0xe, 0x30, 0x20, 0x20, 0x10, 0x11, 0x10, 0x10, 0x8, 0x4, 0x5, 0x2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x41, 0x40, 0x40, 0x78, 0x7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x13, 0x10, 0x10, 0x1f, 0x00, 0x00, 0x7, 0x18, 0x10, 0x8, 0xb, 0xc, 0x00, 0x00, 0x1, 0x1, 0x2, 0x2, 0x4, 0x4, 0x4, 0x84, 0x82, 0x2, 0x3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x10, 0x8, 0x4, 0x4, 0x84, 0x84, 0x84, 0x4, 0x8, 0x10, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x88, 0x8, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x10, 0x10, 0x10, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x4, 0x4, 0x2, 0xea, 0x11, 0xa1, 0x41, 0x1, 0x2, 0x6, 0x98, 0x60, 0x00, 0x00, 0x00, 0x1, 0x3f, 0xc1, 0x1, 0x1, 0x1, 0xff, 0x00, 0x2, 0xe, 0x11, 0x61, 0x81, 0x1, 0x00, 0x1, 0x6, 0x18, 0x60, 0x80, 0x60, 0x18, 0x4, 0x3, 0x00, 0x00, 0x80, 0x40, 0x31, 0x9, 0x7, 0x1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x38, 0x47, 0x81, 0x00, 0x00, 0x00, 0x3, 0x4, 0x8, 0x8, 0x4, 0x2, 0x1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x1, 0x3e, 0x40, 0x40, 0x80, 0x40, 0x3f, 0x00, 0x00, 0x00, 0xf8, 0x7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x3, 0x1, 0x00, 0x00, 0x10, 0x2c, 0x42, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x1f, 0x10, 0x20, 0x20, 0x40, 0xc0, 0x1, 0x2, 0xc, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xc, 0x2, 0x1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3, 0xc, 0x30, 0x40, 0x40, 0x40, 0x80, 0x81, 0x82, 0x82, 0x82, 0x82, 0x2, 0x2, 0x82, 0x62, 0x1a, 0x6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7, 0x78, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x10, 0x8, 0x8, 0x7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3, 0x7c, 0x40, 0x20, 0x38, 0x7, 0x6, 0x18, 0x10, 0x10, 0x11, 0x12, 0x14, 0x18, 0x10, 0x00, 0x00, 0x00, 0x3, 0x2, 0x2, 0x4, 0x4, 0x4, 0x4, 0x8, 0xf, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1, 0x1, 0x1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

// Predeclare functions
void stepTitleScreen();

void stepPlayerSelect();

void attemptMove(const uint8_t & x, const uint8_t & y, const Cell & cell);

void stepGameplay();

void testPrint();

void drawCell(const Cell & cell);

void drawGrid();

bool isWinner(const Cell & cell);

bool isTie();

void clearGrid();

void setup() {
  ab.begin();
  ab.setFrameRate(1);
  ab.initRandomSeed();
  ab.clear();
}

void loop() {
  if (!(ab.nextFrame()))
    return;
    ab.clear();

  switch(gamestate)
  {
    case GameState::TitleScreen:
      stepTitleScreen();
      break;
    case GameState::PlayerSelect:
      stepPlayerSelect();
      break;
    case GameState::Gameplay:
      stepGameplay();
      break;
    default: // If in doubt, return to title
      gamestate = GameState::TitleScreen;
      break;
  }
  ab.display();
}

void stepTitleScreen()
{
  ab.drawBitmap((0), (0), titles, 128, 54, WHITE);
  ab.setCursor((0), (55)); 
  ab.print("VERSION 1.1 PRESS A");
  if (ab.pressed(A_BUTTON)) {
    ab.clear();
    gamestate = GameState::PlayerSelect;
  }
}

void stepPlayerSelect()
{
  ab.setCursor((23), (0)); 
  ab.print("How Many Players?");
  ab.setCursor((5), (10)); 
  ab.print("LEFT or RIGHT select");
  ab.setCursor((35), (25)); 
  ab.print("B to PLAY"); 
  
  if(ab.pressed(LEFT_BUTTON)) { 
    players = 1;
  } 

  if(ab.pressed(RIGHT_BUTTON)) { 
    players = 2;
  } 
  
  if(ab.pressed(B_BUTTON)) { 
    gamestate = GameState::Gameplay;
  }
  
  ab.setCursor((29), (49)); 
  switch(players)
  {
    case 1:
      ab.print("1 Player");
      break;
    case 2:
      ab.print("2 Players");
      break;
    default:
      players = 1; 
      break;
  }
}

void attemptMove(const uint8_t & x, const uint8_t & y, const Cell & cell)
{
    if(grid[x][y] == Cell::None)
    {
      grid[x][y] = cell;
      turn = oppositeCell(cell);
    }
}

void stepGameplay()
{
  ab.clear();
  if(ab.pressed(B_BUTTON)) { 
    turn = Cell::X;
    clearGrid();
  }
  
  if(turn == Cell::O)
  {
  const uint8_t randX = random(0, 3);
  const uint8_t randY = random(0, 3);
  attemptMove(randX, randY, Cell::O);
  }  
  else if(turn == Cell::X)
  {
    if(ab.pressed(A_BUTTON))
    {
      attemptMove(xloc, yloc, Cell::X);
    }
  }
 
  if (isTie()){      
    ++ties;
    clearGrid();
  }
  else if (isWinner(Cell::X)) {      
    ++xwins;
    clearGrid();
  }
  else if (isWinner(Cell::O)) {      
    ++owins;
    clearGrid();
  }

  if(ab.pressed(LEFT_BUTTON) && (xloc > 0)) {
    --xloc;
  }
  if(ab.pressed(RIGHT_BUTTON) && (xloc < 2)) {
    ++xloc;
  }
  if(ab.pressed(UP_BUTTON) && (yloc > 0)) {
    --yloc;
  }
  if(ab.pressed(DOWN_BUTTON) && (yloc < 2)) {
    ++yloc;
  }
  
  testPrint();
 
  const GridPoint drawPos = gridPositions[xloc][yloc];
  ab.drawBitmap((drawPos.x - 2), (drawPos.y - 1), player, 10, 10, WHITE);
    
  drawGrid();
}

void testPrint()
{
  // test stuff get rid of eventualy
  ab.setCursor((70), (0)); 
  ab.print("X WINS");
  ab.setCursor((110), (0)); 
  ab.print(xwins);
  ab.setCursor((70), (15)); 
  ab.print("O WINS");
  ab.setCursor((110), (15)); 
  ab.print(owins);
  
  ab.setCursor((70), (30));
  ab.print("TIES");
  ab.setCursor((110), (30)); 
  ab.print(ties);
  ab.setCursor((70), (40));
  ab.print("Turn");
  ab.setCursor((110), (40)); 

  drawCell(turn);
  // end test stuff
}

void drawCell(const Cell & cell)
{
  switch(cell)
  {
    case Cell::X:
      ab.print('X');
      break;
    case Cell::O:
      ab.print('O');
      break;
    default:
      break;
  }
}

void drawGrid()
{
  ab.drawFastHLine(0, 21, 63, WHITE); //TOP line
  ab.drawFastHLine(0, 42, 63, WHITE); //BOTTOM line
  ab.drawFastVLine(21, 0, 63, WHITE); //LEFT line
  ab.drawFastVLine(42, 0, 63, WHITE); //RIGHT line

  for(uint8_t y = 0; y < 3; ++y)
  {
    for(uint8_t x = 0; x < 3; ++x)
    {
      const GridPoint pos = gridPositions[x][y];
      ab.setCursor(pos.x, pos.y);
      drawCell(grid[x][y]);
    }
  }
}

// Tip: Don't use 'or' - use '||'.
// 'or' is old fashioned and isn't really used anymore.
bool isWinner(const Cell & cell)
{
  return
    (grid[0][0] == cell) && (grid[1][0] == cell) && (grid[2][0] == cell) ||
    (grid[0][1] == cell) && (grid[1][1] == cell) && (grid[2][1] == cell) ||
    (grid[0][2] == cell) && (grid[1][2] == cell) && (grid[2][2] == cell) ||
    (grid[0][0] == cell) && (grid[0][1] == cell) && (grid[0][2] == cell) ||
    (grid[1][0] == cell) && (grid[1][1] == cell) && (grid[1][2] == cell) ||
    (grid[2][0] == cell) && (grid[2][1] == cell) && (grid[2][2] == cell) ||
    (grid[0][0] == cell) && (grid[1][1] == cell) && (grid[2][2] == cell) ||
    (grid[2][0] == cell) && (grid[1][1] == cell) && (grid[0][2] == cell);
}

bool isTie()
{
    for(uint8_t y = 0; y < 3; ++y)
    {
      for(uint8_t x = 0; x < 3; ++x)
      {
        if(grid[x][y] == Cell::None)
          return false;
      }
    }
    return true;
}

void clearGrid()
{
    for(uint8_t y = 0; y < 3; ++y)
    {
      for(uint8_t x = 0; x < 3; ++x)
      {
        grid[x][y] = Cell::None;
      }
    }
}
